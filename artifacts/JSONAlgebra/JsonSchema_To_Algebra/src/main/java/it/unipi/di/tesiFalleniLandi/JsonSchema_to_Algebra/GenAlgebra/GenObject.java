package it.unipi.di.tesiFalleniLandi.JsonSchema_to_Algebra.GenAlgebra;

import com.google.common.collect.Lists;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import it.unipi.di.tesiFalleniLandi.JsonSchema_to_Algebra.Commons.ComplexPattern.ComplexPattern;
import it.unipi.di.tesiFalleniLandi.JsonSchema_to_Algebra.WitnessAlgebra.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.uni_passau.sds.patterns.REException;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Collectors.*;

public class GenObject implements GenAssertion {
    private static Logger logger = LogManager.getLogger(GenObject.class);
    private JsonElement witness;


    private Double minPro, maxPro;
    private List<GProperty> CPart;
    private List<GOrPattReq> RPart;
    private List<GPattReq> objectReqList;
    private boolean _randomStrategy;



    /*generic functions*/
    public static List<String> generateNames(ComplexPattern pattern, Double maxSize) {
        return generateNames(pattern, maxSize, new LinkedList<>());
    }

    /**
     * returns the set of strings generated by key and excluding excludeNames up to maxSize
     * if cannot generate maxSize names then returns an empty list (?)
     *
     * @param maxSize
     * @param excludedNames
     * @return
     */
    public static List<String> generateNames(ComplexPattern originalPattern, Double maxSize, List<String> excludedNames) {
        List<String> excluded = new LinkedList<>(),
                result = new LinkedList<>();
        String currentName;
        int count = 0;

        if (originalPattern.domainSize() < maxSize)
            return result;

        excluded.addAll(excludedNames);

        //ComplexPattern key = getDefaultPattern(pattern);
        ComplexPattern letterDigitPattern = originalPattern;

        try { letterDigitPattern = originalPattern.intersect(ComplexPattern.createFromRegexp("^[a-zA-Z0-9]+$"));}
        catch (REException e) { e.printStackTrace(); }

        ComplexPattern currentPattern = letterDigitPattern;

        while (count < maxSize) {
            try {
                currentName = currentPattern.generateNewWord(excluded);
                if (currentName != null) {
                    excluded.add(currentName);
                    result.add(currentName);
                    count++;
                } else if (currentPattern == letterDigitPattern) {
                    currentPattern = originalPattern;
                } else
                    return result;
            } catch (REException e) {
                e.printStackTrace();
            }
        }
        return result;

    }
  /*
    /**
     * to make sure that the pattern produces a non-empty string
     *
     * @param pattern
     * @return
     *
    public ComplexPattern getDefaultPattern(ComplexPattern pattern) {

        try {
            ComplexPattern defaultPattern = ComplexPattern.createFromRegexp("[a-zA-Z0-9]+");
            if (defaultPattern.intersect(pattern).domainSize() >= minPro) {
                pattern = pattern.intersect(defaultPattern);
            }
        } catch (REException e) {
            e.printStackTrace();
        }

        return pattern;

    }
*/

/*    public String generateName(ComplexPattern key) {
        ComplexPattern letterDigitKey = key.intersect(ComplexPattern.createFromRegexp("^[a-zA-Z0-9]+$"));
        String name = null;
        try {
            name = letterDigitKey.generateNewWord();
        } catch (Exception e) {
            try {
                name = key.generateNewWord();
            } catch (REException e) {
                e.printStackTrace();
            }
        }
        return name;
    }*/

    @Override
    public String toString() {
        return "GenObject{" + _sep +
                "minPro=" + minPro + _sep +
                ", maxPro=" + maxPro + _sep +
                ", CPart=" + CPart + _sep +
                ", RPart=" + RPart + _sep +
                ", objectReqList=" + objectReqList + _sep +
                '}' + _sep;
    }

    @Override
    public JsonElement getWitness() {
        return witness;
    }

    /**
     *
     * @param solution
     * @return
     */
    private String printSolutionWithStatus(List<GPattReq> solution){
        String output ="";// = "==variable status==\n";
        Map<String,String> outputMap = new HashMap<>();
        solution.forEach(gPattReq ->
                outputMap.put(gPattReq.getSchema().getName(),
                        gPattReq.getStatus().toString()));
        for(Map.Entry<String,String> entry:outputMap.entrySet())
            output+=entry.getKey()+"\t"+entry.getValue()+"\n";

        return output;
    }

    /*local classes*/
    /* WitnessProperty counterpart*/
    public class GProperty {
        private ComplexPattern key;
        private GenVar schema;

        public GenVar usedVar() {
            return schema;
        }


        @Override
        public String toString() {
            return "GProperty{" +
                    "key=" + key +
                    ", schema=" + schema +
                    '}';
        }

        public GProperty(WitnessProperty prop, GenEnv env) {
            String varname;
            WitnessAssertion value = prop.getValue();
            if (value.getClass() == WitnessBoolean.class)
                schema = ((WitnessBoolean) value).getValue() == true ? new GenVarTrue("dummy") : new GenVarFalse("dummy");
            else if (value.getClass() == WitnessVar.class) {
                //either variable already created in env or needs to be created
                varname = ((WitnessVar) value).getName();
                schema = env.getByNameElseCreate(varname);
            } else
                try {
                    throw new Exception("Properties must be normalized and map to WitnessVar or WitnessBool");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            key = prop.getPattern();
        }

        public float patternDomainSize() {
            return key.domainSize();
        }

        /**
         * TODO temporary (to be removed)
         *
         * @param minPro
         * @return
         */
        public List<String> dummyGenerateNames(Double minPro) {
            String[] alph = {"a", "b", "c", "d", "e"};
            List<String> names = new LinkedList<>();

            for (int i = 0; i <= minPro; i++)
                names.add(alph[i % alph.length] + i);
            return names;
        }

        /**
         * @param maxSize
         * @return
         */
        public List<String> generateNames(Double maxSize) {
            return generateNames(maxSize, new LinkedList<>());
        }


        /**
         * TODO remove redundancy Giorgio: I hope I did remove it
         * returns the set of strings generated by key and excluding excludeNames up to maxSize
         *
         * @param maxSize
         * @param excludedNames
         * @return
         */
        public List<String> generateNames(Double maxSize, List<String> excludedNames) {
            return GenObject.generateNames(this.key, maxSize, excludedNames);
        }
/*            List<String> excluded = new LinkedList<>(),
                    result = new LinkedList<>();
            String current;
            int count = 0;
            if (key.domainSize() < maxSize)
                return result;

            excluded.addAll(excludedNames);

            key = getDefaultPattern(key);

            while (count < maxSize) {
                try {
                    current = key.generateNewWord(excluded);
                    if (current != null) {
                        excluded.add(current);
                        result.add(current);
                    } else
                        return result;
                } catch (REException e) {
                    e.printStackTrace();
                }
                count++;
            }
            return result;
        }

 */
    }

    /*WitnessPattReq counterpart*/
    public class GPattReq {
        private ComplexPattern key;
        private GenVar schema;
        private List<GOrPattReq> orpList;
//        private boolean isSimple;

        public statuses getStatus(){
            return this.schema.getStatus();
        }
        public ComplexPattern getKey() {
            return key;
        }

        public GenVar getSchema() {
            return schema;
        }

        @Override
        public int hashCode() {
            return key.hashCode() * schema.hashCode();
        }

        /**
         * R1 = R2 iff pattern(R1)=pattern(R2) and Var(R1) hasSameNameAs Var(R2)
         *
         * @param obj
         * @return
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            GPattReq other = (GPattReq) obj;
            boolean result = (this.key.equals(other.key) && this.schema.equals(other.schema));
//            System.out.println("comparing "+ this + " with "+ obj + " yields " + result) ;
            return result;
        }

        public List<GOrPattReq> getOrpList() {
            return orpList;
        }

        public float patternDomainSize() {
            return key.domainSize();
        }

        public JsonElement getWitness() {
            return schema.getWitness();
        }

        public GenVar usedVar() {
            return schema;
        }

        @Override
        public String toString() {
            return "GPattReq{" +
                    "key=" + key +
                    ", schema=" + schema +
//                    ", orpList=" + orpList +
                    '}';
        }

        /**
         * @param gOrPattReq
         */
        public void addOrpList(GOrPattReq gOrPattReq) {
            this.orpList.add(gOrPattReq);
        }

        /**
         * @param pattReq
         * @param env
         */
        public GPattReq(WitnessPattReq pattReq, GenEnv env) {
            this.orpList = new LinkedList<>();
            String varname;
            WitnessAssertion value = pattReq.getValue();
            if (value.getClass() == WitnessBoolean.class)
                schema = ((WitnessBoolean) value).getValue() == true ? new GenVarTrue("dummy") : new GenVarFalse("dummy");
            else if (value.getClass() == WitnessVar.class) {
                varname = ((WitnessVar) value).getName();
                schema = env.getByNameElseCreate(varname);
//                schema = new GenVar( ((WitnessVar) value).getName());
            } else
                new Exception("Request Properties must be normalized and map to WitnessVar or WitnessBool");
            key = pattReq.getPattern();
//            orpList=pattReq.getOrpList()
//                    .stream().map(e->new GOrPattReq(e)).collect(Collectors.toList());
        }
    }


    /*WitnessOrPattReq counterpart*/
    public class GOrPattReq {
        private List<GPattReq> reqList;

        public List<GenVar> usedVars() {
            return reqList.stream().map(p -> p.usedVar()).collect(Collectors.toList());
        }

        @Override
        public String toString() {
            return "GOrPattReq{" +
                    "reqList=" + reqList +
                    '}';
        }

        /**
         * TODO duplicate elimination added as a verification and should be removed later
         *
         * @param witnessOrPattReq
         * @param env
         */
        public GOrPattReq(WitnessOrPattReq witnessOrPattReq, GenEnv env) {
            reqList = new LinkedList<>();
            reqList = witnessOrPattReq.getReqList().stream().map(w -> new GPattReq(w, env))//.sorted()
                    .distinct().collect(Collectors.toList());
//            for(WitnessPattReq witnessPattReq: witnessOrPattReq.getReqList())
//                reqList.add(new GPattReq(witnessPattReq));
        }

        /**
         * returns true when all variables are empty or when the request list is empty
         *
         * @return
         */
        public boolean allVarsEmpty() {
            Optional<Boolean> res = null;
            res = this.reqList.stream().map(req -> req.usedVar().isEmpty())
                    .reduce((a, b) -> a && b);
            if (res.isPresent())
                return res.get();
            else
                return true; //empty list is considered to be Empty
        }
    }


    /*Methods*/

    public GenObject() {
        this.CPart = new LinkedList<>();
        this.RPart = new LinkedList<>();
        this.objectReqList = new LinkedList<>();
        this.setDefaultMinMaxPro();
        //TODO remove after object preparation fixed
        _randomStrategy = false;
    }

    public void setCPart(List<WitnessProperty> propList, GenEnv env) {
        this.CPart = propList.stream().map(p -> new GProperty(p, env)).collect(Collectors.toList());
    }

    public void setRPart(List<WitnessOrPattReq> orPattReqList, GenEnv env) {
        this.RPart = orPattReqList.stream().map(p -> new GOrPattReq(p, env))
                .collect(Collectors.toList());
    }

    /**
     *
     */
    public void setObjectReqList() {
        if (this.RPart.size() > 0) {
            //flatten RPart
            for (GOrPattReq gOrPattReq : RPart)
                for (GPattReq gPattReq : gOrPattReq.reqList)
                    this.objectReqList.add(gPattReq);
            this.objectReqList = objectReqList.stream().distinct().collect(Collectors.toList());
        }
    }

    /**
     * E.g.
     * orpList: el1:[Pr1, Pr2], el2:[Pr1, Pr3]
     * assigns to Pr1.orplist [el1,el2],
     * Pr2.orpList [el1]
     * Pr3.orpList [el2]
     */
    public void setORPList() {
        for (GPattReq gPattReq : objectReqList)
            for (GOrPattReq gOrPattReq : RPart)
                if (gOrPattReq.reqList.contains(gPattReq))
                    gPattReq.addOrpList(gOrPattReq);
    }

    public void setMinMaxPro(WitnessPro minMaxPro) {
        minPro = minMaxPro.getMin();
        maxPro = minMaxPro.getMax();
    }

    public void setDefaultMinMaxPro() {
        minPro = 0.0;
        maxPro = Double.POSITIVE_INFINITY;
    }

    //TODO implement invariants

    private boolean isRPartEmpty() {
        Optional<Boolean> opt = this.RPart.stream().map(orp -> orp.reqList.isEmpty()).reduce((a, b) -> a && b);
        if (opt.isPresent())
            return opt.get();
        else
            return true; //RPart is true
    }
    //aux methods

    /**
     * removes ORPs that are  pointed by headReq
     * @param orpList
     * @param headReq
     * @return
     */
    private  List<GOrPattReq> removeOrps(List<GOrPattReq> orpList, GPattReq headReq){
        List<GOrPattReq> result = new LinkedList<>();
        result.addAll(orpList);
        result.removeAll(headReq.orpList);
        return result;
    }

    /**
     * removes  requests that are pointed by an ORP of headReq
     * @param requests
     * @param headReq
     * @return
     */
    private List<GPattReq> removeRequests(List<GPattReq> requests, GPattReq headReq){
        List<GPattReq> toBeFiltered =  new LinkedList<>(), result = new LinkedList<>();
        result.addAll(requests);
        for(GOrPattReq orp: headReq.getOrpList())
            toBeFiltered.addAll(orp.reqList);
        result.removeAll(toBeFiltered);
        return result;
    }

    /**
     *
     * @param requests
     * @param orpList
     * @return
     */
    private List<List<GPattReq>> hittingSet(List<GPattReq> requests, List<GOrPattReq> orpList){

        if(orpList.isEmpty()){
            List<GPattReq> emptyList = new ArrayList<>();
            List<List<GPattReq>> trivialResult = new ArrayList<>();
            trivialResult.add(emptyList);
            return trivialResult;
        }

        if(requests.isEmpty())
            return new LinkedList<>();

        GPattReq headReq = requests.get(0);

        //advance in both lists
        List<GOrPattReq> tailOrp = removeOrps(orpList, headReq);
        List<GPattReq> tailRequests = removeRequests(requests, headReq);

        List<List<GPattReq>> solWithFirst = new LinkedList<>();
        List<GPattReq> current = new ArrayList<>();

        if(tailRequests.isEmpty()&&tailOrp.isEmpty()){
            current.add(headReq);
            solWithFirst.add(current);
        }
//        if(solutions.isEmpty())
//        {
//            current.add(headReq);
//            solWithFirst.add(current);
//        }
        for(List<GPattReq> solutionOfRest: hittingSet(tailRequests, tailOrp)){
            solutionOfRest.add(headReq);
            solWithFirst.add(solutionOfRest);
        }
        requests.remove(headReq);
        List<List<GPattReq>> solWithoutFirst = hittingSet(requests, orpList);

        solWithFirst.addAll(solWithoutFirst);

        return solWithFirst;
    }
    private boolean isMinimal(List<GPattReq> sol, List<GOrPattReq> orpList){
//        if(sol.isEmpty())
//            return false;
        return true;
    }

    private List<List<GPattReq>> optimizedHittingSet() throws Exception {
        List<List<GPattReq>> result ;
        List<GPattReq> simpleResult, current;
        //ensure variant 1
        if(isRPartEmpty())
            throw new Exception("invariant1 non verified!");
        //collect all requests belonging to orp with 1 request only
        simpleResult = RPart.stream().filter(orp->orp.reqList.size()==1)
                .map(orp->orp.reqList.get(0))
                .distinct().collect(Collectors.toList());

//        if(simpleResult.size()==RPart.size()){
//            result.add(List.copyOf(simpleResult));
//            return result;
//        }
        //TODO recover the previous lines after object preparation is fixed
//        result.add(List.copyOf(simpleResult));

        //proceed with the remaining requests
        List<GOrPattReq> remainingOrpsList = RPart.stream().collect(Collectors.toList());
        remainingOrpsList.removeAll(simpleResult.stream()
                .flatMap(e->e.getOrpList().stream())
                .collect(Collectors.toList()));

        List<GPattReq> remainingRequests = objectReqList.stream().collect(Collectors.toList());
        remainingRequests.removeAll(simpleResult);

        result = hittingSet(remainingRequests,remainingOrpsList)//hittingSetTer(remainingRequests,0,remainingOrpsList)
                .stream().filter(l->isMinimal(l,remainingOrpsList))
                .collect(Collectors.toList());

        if(result.isEmpty())
            result.add(List.copyOf(simpleResult));
        else
        //combine simple result with each solution
        for(int i=0; i<result.size(); i++)
        {
            current = result.get(i);
            current.addAll(simpleResult);
            result.set(i,current);
        }

//        System.out.println("this " + this + "\n \t result "+ result);
        return  result;
    }

    /**
     * TODO verify
     * checks whether all patterns can generate at least as many words as the number of their occurrence
      * @param set
     * @return
     */
    private boolean noPatternIsRepeatedTooOften(List<GPattReq> set){
        Map<ComplexPattern,Long> grouped = set.stream().collect(groupingBy(GPattReq::getKey, Collectors.counting()));
        Optional<Boolean> opt = grouped.keySet().stream().map(p->grouped.get(p)<=p.domainSize())
                .reduce((a,b)->a&&b);
        if(opt.isPresent())
            return opt.get();
        else
            return false;
    }

    private boolean allVarsPop(List<GPattReq> list){
        Optional<Boolean> tv = list.stream().map(p->p.usedVar().isPop()).reduce((a,b)->a&&b);
        if(tv.isPresent())
            return tv.get();
        else
            return false;
    }


    /**
     *
     * @param populatedCpart
     * @return
     */
    private float domainSize(List<GProperty> populatedCpart ){
        Optional<Float> optsum = populatedCpart.stream().map(p->p.patternDomainSize()).reduce((a,b)->a+b);
        float s = 0;
        if(optsum.isPresent())
            s=optsum.get();
        return s;
    }

    @Override
    public statuses generate()  {
        logger.debug("used variables {}",this.usedVars().stream().map(genVar -> genVar.getName()).collect(Collectors.toList()));

        HashMap<String,JsonElement> properties = new HashMap<>();
        witness = new JsonObject();


        //TODO (low) logging for coverage and elapsed time of optimization tests

        //if at least one request is not fulfilled, then the problem does not admit an instance
        for(GOrPattReq orp: RPart)
            if(orp.allVarsEmpty())
            {
                logger.debug("exit due to {} has all its Vars Empty", orp.usedVars().stream().map(genVar -> genVar.getName()).collect(Collectors.toList()));
                return statuses.Empty;
            }

        //if the constraining part fails to reach min, then the problem does not admit an instance
        float s = domainSize(CPart.stream().filter(p->p.usedVar().isOpen()||p.usedVar().isPop()).collect(Collectors.toList()));
        if(s<minPro)
        {
            logger.debug("exit due to  s<minPro");
            return statuses.Empty;
        }


        //deal with the case where RPart is empty. Propagate to the article
        if(RPart.size()>0)
        {
            List<List<GPattReq>> optimizedHittingSet = null,
                            reducedSolutionSet = null;
            try {
                optimizedHittingSet = optimizedHittingSet();
                reducedSolutionSet = optimizedHittingSet.stream()
                        .filter(set->set.size()<=maxPro&&noPatternIsRepeatedTooOften(set))
//                        .filter(set->set.size()<=maxPro)
                        .collect(Collectors.toList());
            } catch (Exception e) {
                e.printStackTrace();
            }
            if(reducedSolutionSet.isEmpty())
            {
                logger.debug("exit due to  reducedSolutionSet.isEmpty() optimizedHittingSet() size {}", optimizedHittingSet.size());
                return statuses.Empty;
            }

            List<List<GPattReq>> popSolutionSet = reducedSolutionSet.stream().filter(l->allVarsPop(l))
                    .collect(Collectors.toList());
            if(popSolutionSet.isEmpty())
                return statuses.Open;

            List<GPattReq> solution;

//            System.out.println("popSolutionSet "+ popSolutionSet);
            //choose the solution either randomly or by taking the one which generates the  largest set of names
            if(_randomStrategy)
                solution = random(popSolutionSet);
            else
                solution = maxLengthStrategy(popSolutionSet);

            //the following verification is an assertion
            if(solution == null)
                try {
                    throw new Exception("Solution must be assigned a value");
                } catch (Exception e) {
                    e.printStackTrace();
                }

            logger.debug("solution {}", solution);
//            logger.debug("status {}", printSolutionWithStatus(solution));


            //old solution which tends to overwrite property names
            // solution.stream().forEach(req->properties.put(this.generateName(req.key),req.getWitness()));
            //grouped : (p, [x])  = solution group by p
            // for each (p, [x]) do properties + = mapping(generateNames(p,len([x])), [x])

            List<String> props ;
            List<GenVar> listVars;
            Map<ComplexPattern, List<GenVar>> grouped =
                    solution.stream().collect(groupingBy(GPattReq::getKey, mapping(GPattReq::getSchema, toList())));

            for(Map.Entry<ComplexPattern,List<GenVar>> entry:grouped.entrySet()){
                listVars  = entry.getValue();
                props = generateNames(entry.getKey(), Double.valueOf(listVars.size()));
                //ensure that len(props) = len([x])
                if(props.size()!=listVars.size())
                    try {
                        throw new Exception("Pattern did not generate enough words!");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                for(int i=0; i<props.size();i++)
                    properties.put(props.get(i),listVars.get(i).getWitness());
            }

           if(properties.size()>=minPro){
                //no need to generate more, we can not generate more than maxPro
                properties.forEach((p,v)->((JsonObject) witness).add(p,v));
                return statuses.Populated;
            }
        }

        //complete with properties from CPart
        List<String> usedNames = Lists.newArrayList(properties.keySet()); //TODO go back to Set implementation
        int usedNamesSize = usedNames.size();
        List<GProperty> populatedCpart = CPart.stream().filter(p->p.usedVar().isPop()).collect(Collectors.toList());
        s = domainSize(populatedCpart);
        if(s < minPro) //TODO: check if s + usedNamesSize < minPro ||  s < minPro
            return statuses.Open;//var remains open until more usedVars become pop

        List<String> generatedNames;

        /**
         * many possible strategies:
         * - depth-first: which exhausts one patterns before moving to the other
         * - width-first: which uses round-robin to satisfy minPro by using every pattern equally
         * - weighted width-first: assign different weights to the branches
         */


        while(properties.size()<minPro){
            for(GProperty prop:populatedCpart)
            {
                generatedNames = prop.generateNames(minPro-usedNamesSize,usedNames);
                if(generatedNames.size()>0)
                {
                    generatedNames.forEach(name->properties.put(name, prop.usedVar().getWitness()));
                    usedNames.addAll(generatedNames);
                    usedNamesSize = usedNames.size(); //update
                    break; //pick behavior
                }
            }
        }

//        while(properties.size()<minPro){
//            //pick (p:x) in PopulatedCP with size (p - usedNames) > 0
//            for(GProperty prop:populatedCpart)
//            {
//                if(prop.usedVar().getStatus()==statuses.Populated)
//                {
//                    generatedNames = prop.generateNames(minPro-usedNamesSize,usedNames);
//                    if(generatedNames.size()>0)
//                    {
//                        generatedNames.forEach(name->properties.put(name, prop.usedVar().getWitness()));
//                        usedNames.addAll(generatedNames);
//                        usedNamesSize = usedNames.size(); //update
//                        break; //pick behavior
//                    }
//                }
//
//            }
//            //TODO check whether the solution is valid by checking the reason of exit
//        }

//        while(properties.size()<minPro){
//            populatedCpartStream = CPart.stream().filter(p->p.usedVar().isPop());
//            populatedCpart = populatedCpartStream.filter(p->!usedNames.contains(this.generateName(p.key)))
//                    .collect(Collectors.toList());
//            if(populatedCpart.size()>0)
//                newp = populatedCpart.remove(0);
//            List<String> names = newp.generateNames(minPro-usedNamesSize); //minPro as upper bound to the number of properties
//            GProperty finalNewp = newp;
//            names.forEach(name->properties.put(name, finalNewp.usedVar().getWitness()));
//            usedNames.addAll(names);
//            usedNamesSize = usedNames.size(); //update
//        }

//        while(properties.size()<minPro){
//            populatedCpart = populatedCpart.stream().filter(p->!usedNames.contains(p.generateName()))
//                    .collect(Collectors.toList());
//            GProperty newp = populatedCpart.remove(0);
//            String name = newp.generateName();
//            properties.put(name,newp.usedVar().getWitness());
//            usedNames.add(name);
//        }
        properties.forEach((p,v)->((JsonObject) witness).add(p,v));
        return statuses.Populated;
    }

    /**
     * pick solution randomly
     * @param solutionSet
     * @return
     */
    private List<GPattReq> random(List<List<GPattReq>> solutionSet){
        Random r = new Random();
        int position = r.nextInt(solutionSet.size());
        return solutionSet.get(position);
    }

    /**
     *
     * @param solutionSet
     * @return
     */
    private List<GPattReq> maxLengthStrategy(List<List<GPattReq>> solutionSet){
        HashMap<Integer,Long> maxMap = new HashMap<>();
        List<GPattReq> solution = null;
        //pick solution with the max number of words
        for(int i=0; i<solutionSet.size(); i++)
            maxMap.put(i,solutionSet.get(i).stream().map(gPattReq -> gPattReq.key).distinct().count());
        Long max = Collections.max(maxMap.values());
//        Long min = Collections.min(maxMap.values());
        for(int i=0; i<solutionSet.size(); i++)
            if(maxMap.get(i)==max){
                solution = solutionSet.get(i);
                break;
            }
        return solution;
    }


    /** //TODO in case we need to deal with problem of
     * sort based on de.uni_passau.sds.patterns than decreasing size of associated assertions
     * @param solution
     * @return
     */
    private List<GPattReq> simplify(List<GPattReq> solution){
        return solution;
    }

    @Override
    public JsonElement generateNext() {
        return null;
    }

    @Override
    public WitnessAssertion toWitnessAlgebra() {
        return null;
    }

    @Override
    public List<GenVar> usedVars() {
        List<GenVar> cpart_vars = CPart.stream().map(gp->gp.usedVar()).collect(Collectors.toList());
        List<GenVar> rpart_vars = RPart.stream().flatMap(op->op.usedVars().stream()).collect(Collectors.toList());
        return Stream.concat(cpart_vars.stream(), rpart_vars.stream())
                .distinct()
                .collect(Collectors.toList());
    }


}

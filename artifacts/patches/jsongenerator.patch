diff --git a/build.gradle b/build.gradle
index cafa219..b59f0a3 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,10 +1,14 @@
 plugins {
     id 'java'
     id 'maven-publish'
+    id 'application'
 }
 
-sourceCompatibility = JavaVersion.VERSION_1_8
-targetCompatibility = JavaVersion.VERSION_1_8
+mainClassName = 'massiveTesting.MainClass'
+applicationDefaultJvmArgs = ["-Dnashorn.args=--no-deprecation-warning"]
+
+sourceCompatibility = JavaVersion.VERSION_11
+targetCompatibility = JavaVersion.VERSION_11
 
 repositories {
     mavenLocal()
@@ -19,6 +23,10 @@ dependencies {
     implementation 'cat.inspiracio:rhino-js-engine:1.7.10'
     implementation 'net.jimblackler.jsonschemafriend:core:0.12.1'
     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.0'
+    implementation 'com.networknt:json-schema-validator:1.0.67'
+    implementation 'org.json:json:20210307'
+    implementation 'com.google.code.gson:gson:2.8.7'
+    implementation 'org.apache.commons:commons-text:1.9'
 }
 
 task sourceJar(type: Jar) {
@@ -39,3 +47,9 @@ afterEvaluate {
         }
     }
 }
+
+run {
+    if (project.hasProperty("data")) {
+        args Eval.me(data)
+    }
+}
diff --git a/src/main/java/massiveTesting/GenerationTask.java b/src/main/java/massiveTesting/GenerationTask.java
new file mode 100644
index 0000000..cb7c93b
--- /dev/null
+++ b/src/main/java/massiveTesting/GenerationTask.java
@@ -0,0 +1,191 @@
+package massiveTesting;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.google.gson.JsonPrimitive;
+import com.networknt.schema.JsonSchemaException;
+import com.networknt.schema.SpecVersion;
+import com.networknt.schema.ValidationMessage;
+import net.jimblackler.jsongenerator.Configuration;
+import net.jimblackler.jsongenerator.DefaultConfig;
+import net.jimblackler.jsongenerator.Generator;
+import net.jimblackler.jsonschemafriend.Schema;
+import net.jimblackler.jsonschemafriend.SchemaStore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.LinkedHashMap;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.*;
+
+public class GenerationTask implements Callable<Boolean> {
+
+    private final File inputSchema;
+    private final String id;
+    SpecVersion.VersionFlag version = SpecVersion.VersionFlag.V201909;
+
+    LinkedHashMap<String, String> resultMap = new LinkedHashMap<>();
+    LinkedHashMap<String, String> witnessMap = new LinkedHashMap<>();
+    LinkedHashMap<String, Set<ValidationMessage>> errorsMap = new LinkedHashMap<>();
+    LinkedHashMap<String, String> validationException = new LinkedHashMap<>();
+
+    boolean witnessGenerationSuccess = false;
+    boolean hasValidationErrors = false;
+    String currentOperation;
+
+
+
+    public GenerationTask(File inputSchema) {
+        this.inputSchema = inputSchema;
+        this.id = Utils.getSchemaId(inputSchema);
+        Utils.initMaps(this.resultMap);
+        this.resultMap.put(Utils.objectId,this.id);
+        this.resultMap.put(Utils.inSize,String.valueOf(inputSchema.length()));
+
+    }
+
+
+    @Override
+    public Boolean call() throws IOException {
+        ObjectMapper objectMapper = new ObjectMapper();
+        ObjectWriter objectWriter = objectMapper.writerWithDefaultPrettyPrinter();
+        SimpleDateFormat formatter = new SimpleDateFormat("HH:mm:ss");
+        Date date = new Date();
+        System.out.println(formatter.format(date)+" :  started processing  " + this.inputSchema.getName()+" of size "+this.inputSchema.length()+" bytes"+"  by thread  "+Thread.currentThread().getName());
+
+
+        long execStart = System.currentTimeMillis();
+
+
+
+        SchemaStore schemaStore = new SchemaStore();
+        Schema schema;
+
+        this.currentOperation = Utils.loadSchema;
+        Future<Schema> futureSchema = null;
+        
+        ExecutorService executor = null;
+        try {
+            executor = Executors.newSingleThreadExecutor();
+            Callable<Schema> loadSchemaTask = () -> {
+                return schemaStore.loadSchema(this.inputSchema);
+            };
+            futureSchema = executor.submit(loadSchemaTask);
+            schema = futureSchema.get(5, TimeUnit.SECONDS);
+            long totalTime = System.currentTimeMillis() - execStart;
+            this.resultMap.put(Utils.loadSchema, String.valueOf(totalTime));
+        } catch (TimeoutException e) {
+            System.out.println("TimeoutException occurred during schema loading: " + e.getMessage());
+            futureSchema.cancel(true);
+            this.resultMap.put(Utils.loadSchema, "TimeoutException");
+            this.resultMap.put(Utils.totalTime, String.valueOf(System.currentTimeMillis() - execStart));
+            return false;
+        } catch (InterruptedException | ExecutionException e) {
+            System.out.println("Exception occurred: " + e.getMessage());
+            this.resultMap.put(Utils.loadSchema, e.getClass().getSimpleName());
+            this.resultMap.put(Utils.totalTime, String.valueOf(System.currentTimeMillis() - execStart));
+            return false;
+        } finally {
+            if (executor != null) {
+                executor.shutdownNow();
+            }
+        }
+
+        String s = schema.toString();
+        int i = s.indexOf("{");
+        String schemaAsString = null;
+        if(i!=-1)
+            schemaAsString = s.substring(i);
+
+        if (schemaAsString==null)
+            return  false;
+
+//        JsonPrimitive schemaObject = new JsonPrimitive(schemaAsString);
+
+        this.version = Utils.getVersionFlag(this.inputSchema.getAbsolutePath());
+
+        this.currentOperation = Utils.initGenerator;
+        Generator generator;
+        try {
+            long start = System.currentTimeMillis();
+            Configuration config = DefaultConfig.build()
+                    .setPedanticTypes(true)
+                    .setGenerateNulls(false)
+                    .setGenerateMinimal(false)
+                    .setGenerateAdditionalProperties(false)
+                    .setUseRomanCharsOnly(true)
+                    .setNonRequiredPropertyChance(1.0f)
+                    .get();
+            generator = new Generator(config, schemaStore, new Random(1));
+
+            long end = System.currentTimeMillis();
+            this.resultMap.put(Utils.initGenerator,String.valueOf(end - start));
+        }catch (Exception e) {
+            this.resultMap.put(Utils.initGenerator,e.getClass().getSimpleName());
+            this.resultMap.put(Utils.totalTime,String.valueOf(System.currentTimeMillis()-execStart));
+            return false;
+        }
+
+        this.currentOperation = Utils.generation;
+        Object object;
+        try {
+            long start = System.currentTimeMillis();
+            object = generator.generate(schema, 1);
+            long end = System.currentTimeMillis();
+            this.resultMap.put(Utils.generation,String.valueOf(end - start));
+        }catch (Exception e) {
+            this.resultMap.put(Utils.generation,e.getClass().getSimpleName());
+            this.resultMap.put(Utils.totalTime,String.valueOf(System.currentTimeMillis()-execStart));
+            return false;
+        }
+
+        this.resultMap.put(Utils.totalTime,String.valueOf(System.currentTimeMillis()-execStart));
+        this.currentOperation = Utils.valid;
+
+        if(object==null) {
+            this.resultMap.put(Utils.genSuccess, "false");
+            this.resultMap.put(Utils.valid, "");
+            return false;
+        }
+
+        else {
+            String witness;
+            JsonPrimitive js;
+            if(object instanceof  String) {
+                js = new JsonPrimitive(object.toString());
+                witness = js.toString();
+            }
+            else
+                witness = objectWriter.writeValueAsString(object);
+            this.witnessGenerationSuccess = true;
+            this.witnessMap.put(this.id,witness);
+            this.resultMap.put(Utils.genSuccess,"true");
+
+            Set<ValidationMessage> errors;
+            String schema2 = Files.readString(Path.of(this.inputSchema.toString()));
+            try {
+                errors = Utils.validateStringWitness(schema2,witness,this.version,this.id,this.validationException);
+            } catch (JsonSchemaException e) {
+                this.resultMap.put(Utils.valid,e.getClass().getSimpleName());
+                Utils.addValidationException(id,e,validationException);
+                return false;
+            }
+
+            boolean err = errors.size()==0;
+            this.resultMap.put(Utils.valid,String.valueOf(err));
+            if (!err)  {
+                this.hasValidationErrors = true;
+                this.errorsMap.put(this.id, errors);
+            }
+        }
+
+        System.out.println(this.resultMap);
+
+        return true;
+    }
+}
diff --git a/src/main/java/massiveTesting/MainClass.java b/src/main/java/massiveTesting/MainClass.java
new file mode 100644
index 0000000..ec46199
--- /dev/null
+++ b/src/main/java/massiveTesting/MainClass.java
@@ -0,0 +1,142 @@
+package massiveTesting;
+
+import com.networknt.schema.ValidationMessage;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.*;
+
+public class MainClass {
+
+    public static void main(String[] args) throws InterruptedException, IOException {
+        long timeout = 1000 * 60 * 180;
+        int nbProcs = Runtime.getRuntime().availableProcessors();
+        System.out.println(nbProcs);
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, Integer.MAX_VALUE,
+                1, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
+        ExecutorService writerExec = Executors.newSingleThreadExecutor();
+
+        SimpleDateFormat formatter = new SimpleDateFormat("ddMMyyyy_HHmmss");
+        Date date = new Date();
+        String info = "jsongenerator_"+formatter.format(date)+"_"+timeout+"ms_";
+        if (args.length == 0) {
+            System.out.println("Usage: <path>");
+            return;
+        }
+        String path = args[0];
+        File[] files = new File(path).listFiles();
+        System.out.println(files);
+        Arrays.sort(files, Comparator.comparing(f -> f.length()));
+
+        File resultsFolder = new File(path+"/results");
+        if (!resultsFolder.exists())
+            resultsFolder.mkdir();
+
+        BufferedWriter csvFile = Utils.createBufferedWriter(resultsFolder.getPath(),info+"results.csv");
+        Utils.setCSVHeader(csvFile);
+
+        BufferedWriter witnessFile = Utils.createBufferedWriter(resultsFolder.getPath(), info+"witness.csv");
+        witnessFile.write("objectId,witness\n");
+
+        BufferedWriter validationErrorsFile = Utils.createBufferedWriter(resultsFolder.getPath(), info+"validation.csv");
+        validationErrorsFile.write("objectId,nbErrors,errorsTypes,errorsMessages\n");
+
+        BufferedWriter validationExceptionFile = Utils.createBufferedWriter(resultsFolder.getPath(), info+"validationException.csv");
+        validationExceptionFile.write("objectId,exceptionName,message\n");
+
+        long start = System.currentTimeMillis();
+        System.out.println(start);
+
+
+        LinkedHashMap<File,GenerationTask> fileTaskMap = new LinkedHashMap<>();
+
+
+        for (File file : files){
+            if (!file.getName().endsWith(".json")) {
+                System.out.println("skipping non-json file: " + file.getName()+"\n\n");
+                continue;
+            }
+            GenerationTask task = new GenerationTask(file);
+            fileTaskMap.put(file,task);
+        }
+
+
+        List<Future<Boolean>> futures = null;
+
+        try {
+            futures = executor.invokeAll(fileTaskMap.values()); // execution without a timeout
+//            futures = executor.invokeAll(fileTaskMap.values(),timeout,TimeUnit.MILLISECONDS); // execution with a timeout
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+        executor.shutdown();
+
+
+        for(int i=0;i<futures.size();i++) {
+            Future<Boolean> future = futures.get(i);
+            File file = (File) fileTaskMap.keySet().toArray()[i];
+            GenerationTask task = fileTaskMap.get(file);
+            try {
+                future.get();
+            } catch (InterruptedException | ExecutionException | CancellationException e) {
+                task.resultMap.put(task.currentOperation,e.getClass().getSimpleName());
+            }
+
+            LinkedHashMap<String, String> resultMap = task.resultMap;
+
+            LinkedHashMap<String, String> witnessMap = task.witnessMap;
+
+            LinkedHashMap<String, Set<ValidationMessage>> validationErrorsMap = task.errorsMap;
+
+            LinkedHashMap<String,String> validationException = task.validationException;
+
+
+            Runnable writer = new WriteResults(resultMap,witnessMap,validationErrorsMap,csvFile,witnessFile,
+                    validationErrorsFile, task.witnessGenerationSuccess, task.hasValidationErrors,file,
+                    validationException, validationExceptionFile);
+
+            writerExec.submit(writer);
+        }
+
+        writerExec.shutdown();
+
+        while(!writerExec.isTerminated())
+            System.out.print("");
+
+
+
+
+        csvFile.flush();
+        csvFile.close();
+        witnessFile.flush();
+        witnessFile.close();
+        validationErrorsFile.flush();
+        validationErrorsFile.close();
+        validationExceptionFile.flush();
+        validationExceptionFile.close();
+
+
+        long totalTimeInMS = System.currentTimeMillis()-start;
+        long mn = (totalTimeInMS / 1000) / 60;
+        long s = (totalTimeInMS / 1000) % 60;
+        System.out.println("\n\n***************************************************");
+        System.out.println("Total time : "+mn+" minutes and "+s+ " seconds");
+        System.out.println("***************************************************\n\n");
+
+
+        Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
+
+        // Exiting the program when a thread from the previous pool is still running (when stuck in dnf for example)
+        // Didn't find any other alternative to stop the thread from running
+        for(Thread t : threadSet)
+            if(t.getName().contains("pool")) {
+//                System.out.println(t + "   " + t.getName() + "   " + t.getPriority() + "   " + t.getThreadGroup().getName());
+                System.exit(-1);
+            }
+
+    }
+}
diff --git a/src/main/java/massiveTesting/Utils.java b/src/main/java/massiveTesting/Utils.java
new file mode 100644
index 0000000..2286947
--- /dev/null
+++ b/src/main/java/massiveTesting/Utils.java
@@ -0,0 +1,241 @@
+package massiveTesting;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.JsonElement;
+import com.networknt.schema.*;
+import org.apache.commons.lang3.StringEscapeUtils;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class Utils {
+
+    final static String objectId = "objectId";
+    final static String inSize = "inSize";
+    final static String totalTime = "totalTime";
+    final static String loadSchema = "loadSchema";
+    final static String initGenerator = "initGenerator";
+    final static String generation = "generation";
+    final static String genSuccess = "genSuccess";
+    final static String valid = "valid";
+
+    final static LinkedList<String> ops = new LinkedList<>(Arrays.asList(objectId,
+            inSize, totalTime, loadSchema, initGenerator, generation, genSuccess, valid));
+
+    final static String exceptionName = "exceptionName";
+    final static String message = "message";
+
+
+    private static Pattern p4 = Pattern.compile("/draft-04/");
+    private static Pattern p6 = Pattern.compile("/draft-06/");
+    private static Pattern p7 = Pattern.compile("/draft-07/");
+    private static Pattern regexXbool = Pattern.compile("(\"exclusiveMinimum\"|\"exclusiveMaximum\"):(false|False|true|True)");
+
+
+    //*****************************************************************************************************************
+
+    public static String getSchemaId(File file){
+        return file.getName().replaceAll(".json","");
+    }
+
+
+    static void initMaps(LinkedHashMap<String, String> resultMap){
+        for(String op: ops) {
+            resultMap.put(op,"");
+        }
+    }
+
+
+
+    static void addValidationException(String id, Exception e, LinkedHashMap<String, String> validationException) {
+        validationException.put(objectId,id);
+        validationException.put(exceptionName,e.getClass().getSimpleName());
+        validationException.put(message, StringEscapeUtils.escapeCsv(e.getMessage()));
+    }
+
+
+    //****************************************************************************************************************
+    public static SpecVersion.VersionFlag getVersionFlag(String pathToFile) throws IOException {
+        SpecVersion.VersionFlag version = SpecVersion.VersionFlag.V201909;
+
+
+        String s = Files.readString(Path.of(pathToFile));
+        s = s.replace(" ","");
+//        System.out.println(s);
+        if(p4.matcher(s).find() || regexXbool.matcher(s).find())
+            version = SpecVersion.VersionFlag.V4;
+        else if(p6.matcher(s).find())
+            version = SpecVersion.VersionFlag.V6;
+        else if(p7.matcher(s).find())
+            version = SpecVersion.VersionFlag.V7;
+
+        return version;
+    }
+
+    public static Set<ValidationMessage> validateStringWitness(String schemaString, String witness, SpecVersion.VersionFlag version,
+                                                               String id, LinkedHashMap<String,String> validationException)
+    {
+
+//        System.out.println(version);
+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(version);
+//        System.out.println(schemaString);
+//        JsonSchemaFactory factory = null;
+//        try {
+//            factory = getJsonSchemaFactory(version);
+//        } catch (Exception e) {
+//            e.printStackTrace();
+//        }
+        ObjectMapper mapper = new ObjectMapper();
+
+
+        JsonSchema schema = null;
+        try {
+            schema = factory.getSchema(schemaString);
+        }catch (JsonSchemaException e) {
+//            System.out.println(id+" ___Here ---> "+e.getMessage());
+            addValidationException(id,e,validationException);
+        }
+
+//        System.out.println(schema);
+        JsonNode node = null;
+        try {
+            node = mapper.readTree(witness);
+        } catch (JsonProcessingException e) {
+//            System.out.println(id+" ---> "+e.getMessage());
+            addValidationException(id,e,validationException);
+        }
+        Set<ValidationMessage> errors = schema.validate(node);
+
+//        for (ValidationMessage m: errors){
+//            System.out.println(m);
+//        }
+
+
+        return errors;
+    }
+
+    //*****************************************************************************************************************
+    static void setCSVHeader(BufferedWriter res){
+        try {
+            String header = String.join(",",ops);
+            res.write(header+"\n");
+        }catch (IOException e){
+            e.printStackTrace();
+        }
+
+    }
+
+    static BufferedWriter createBufferedWriter(String path, String filename) {
+        BufferedWriter bw;
+        File file = new File(path + "/" + filename);
+        try {
+            FileWriter fw = new FileWriter(file.getAbsoluteFile());
+            bw = new BufferedWriter(fw);
+            return bw;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+
+
+    //*****************************************************************************************************************
+
+
+    static void writeResultsOnCSV(LinkedHashMap<String, String> resultMap, BufferedWriter csvFile) throws IOException {
+        StringBuilder sb = new StringBuilder();
+
+        sb.append(resultMap.get(objectId))
+                .append(",")
+                .append(resultMap.get(inSize))
+                .append(",")
+                .append(resultMap.get(totalTime))
+                .append(",")
+                .append(resultMap.get(loadSchema))
+                .append(",")
+                .append(resultMap.get(initGenerator))
+                .append(",")
+                .append(resultMap.get(generation))
+                .append(",")
+                .append(resultMap.get(genSuccess))
+                .append(",")
+                .append(resultMap.get(valid))
+                .append("\n");
+
+        csvFile.write(sb.toString());
+    }
+
+    static void writeOnWitnessFile(LinkedHashMap<String, String> witnessMap, BufferedWriter witnessFile) throws IOException {
+        Map.Entry<String, String> entry = witnessMap.entrySet().iterator().next();
+        String id = entry.getKey();
+        String witness = entry.getValue();
+
+        StringBuilder w = new StringBuilder();
+        witness = StringEscapeUtils.escapeCsv(witness);
+        w.append(id+","+witness+"\n");
+        witnessFile.write(w.toString());
+    }
+
+
+    static void writeOnErrorsFile(LinkedHashMap<String, Set<ValidationMessage>> errorsMap, BufferedWriter errorsFile) throws IOException {
+        Map.Entry<String, Set<ValidationMessage>> entry = errorsMap.entrySet().iterator().next();
+        String id = entry.getKey();
+        Set<ValidationMessage> errors = entry.getValue();
+
+        String w = "";
+
+        List<String> errorsTypes = errors.stream().map(m -> m.getType()).collect(Collectors.toList());
+
+        String s1 = "";
+        for (int i=0; i<errorsTypes.size();i++) {
+            String errorType = errorsTypes.get(i);
+            s1 = s1.concat(errorType);
+            if(i<errorsTypes.size()-1)
+                s1 = s1.concat(",");
+        }
+
+        s1 = StringEscapeUtils.escapeCsv(s1);
+
+        String s2 = "";
+        int i=0;
+        for(Iterator<ValidationMessage> it = errors.iterator(); it.hasNext(); ){
+            i++;
+            String message = it.next().getMessage();
+            s2 = s2.concat(message);
+            if(i<errors.size()-1)
+                s2 = s2.concat(",");
+        }
+
+//        String errorsMessagesString = StringEscapeUtils.escapeCsv(sb2.toString());
+
+
+        s2 = s2.replace(",","    ");
+        w = w.concat(id+","+errors.size()+","+s1+","+s2+"\n");
+        errorsFile.write(w);
+    }
+
+
+
+    static void writeOnValidationException(LinkedHashMap<String, String> validationException, BufferedWriter validationExceptionFile) throws IOException {
+        StringBuilder sb = new StringBuilder();
+        sb.append(validationException.get(objectId))
+                .append(",")
+                .append(validationException.get(exceptionName))
+                .append(",")
+                .append(validationException.get(message))
+                .append("\n");
+
+        validationExceptionFile.write(sb.toString());
+
+    }
+}
diff --git a/src/main/java/massiveTesting/WriteResults.java b/src/main/java/massiveTesting/WriteResults.java
new file mode 100644
index 0000000..113a3be
--- /dev/null
+++ b/src/main/java/massiveTesting/WriteResults.java
@@ -0,0 +1,89 @@
+package massiveTesting;
+
+import com.networknt.schema.ValidationMessage;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Set;
+
+public class WriteResults implements  Runnable{
+
+    LinkedHashMap<String, String> resultMap;
+    LinkedHashMap<String, String> witnessMap;
+    LinkedHashMap<String, Set<ValidationMessage>> validationErrorsMap;
+    LinkedHashMap<String, String> validationException;
+    BufferedWriter csvFile;
+    BufferedWriter witnessFile;
+    BufferedWriter validationErrorsFile;
+    BufferedWriter validationExceptionFile;
+    Boolean witnessGenerationSuccess;
+    Boolean hasValidationErrors;
+    File file;
+
+
+    public WriteResults(LinkedHashMap<String, String> resultMap, LinkedHashMap<String, String> witnessMap,
+                        LinkedHashMap<String, Set<ValidationMessage>> validationErrorsMap,
+                        BufferedWriter csvFile,  BufferedWriter witnessFile, BufferedWriter validationErrorsFile,
+                        Boolean witnessGenerationSuccess, Boolean hasValidationErrors, File file,
+                        LinkedHashMap<String, String> validationException,BufferedWriter validationExceptionFile) {
+
+        this.resultMap = resultMap;
+        this.witnessMap = witnessMap;
+        this.validationErrorsMap = validationErrorsMap;
+        this.csvFile = csvFile;
+        this.witnessFile = witnessFile;
+        this.validationErrorsFile = validationErrorsFile;
+        this.witnessGenerationSuccess = witnessGenerationSuccess;
+        this.hasValidationErrors = hasValidationErrors;
+        this.file = file;
+        this.validationException = validationException;
+        this.validationExceptionFile = validationExceptionFile;
+    }
+
+
+
+
+
+    @Override
+    public void run() {
+
+        try {
+            Utils.writeResultsOnCSV(this.resultMap,this.csvFile);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        this.resultMap.clear();
+
+        if(this.witnessGenerationSuccess) {
+            try {
+                Utils.writeOnWitnessFile(this.witnessMap, this.witnessFile);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        this.witnessMap.clear();
+
+
+        if(this.hasValidationErrors) {
+            try {
+                Utils.writeOnErrorsFile(this.validationErrorsMap, this.validationErrorsFile);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        this.validationErrorsMap.clear();
+
+
+        if(this.validationException.size()>0) {
+            try {
+                Utils.writeOnValidationException(this.validationException, this.validationExceptionFile);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        this.validationException.clear();
+
+    }
+}
diff --git a/src/main/java/net/jimblackler/jsongenerator/Fixer.java b/src/main/java/net/jimblackler/jsongenerator/Fixer.java
index 6f1c74a..7d9fee5 100644
--- a/src/main/java/net/jimblackler/jsongenerator/Fixer.java
+++ b/src/main/java/net/jimblackler/jsongenerator/Fixer.java
@@ -56,6 +56,8 @@ public class Fixer {
         break;
       }
 
+      if (attempt==500)
+        break;
       attempt++;
 
       System.out.println("Attempt " + attempt + ":");
diff --git a/src/test/java/net/jimblackler/jsongenerator/Test.java b/src/test/java/net/jimblackler/jsongenerator/Test.java
index a5ec5b8..8626bce 100644
--- a/src/test/java/net/jimblackler/jsongenerator/Test.java
+++ b/src/test/java/net/jimblackler/jsongenerator/Test.java
@@ -3,8 +3,10 @@ package net.jimblackler.jsongenerator;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectWriter;
 import java.io.BufferedWriter;
+import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
@@ -21,28 +23,31 @@ public class Test {
   public static void main(String[] args) throws URISyntaxException, SchemaException, IOException {
     ObjectMapper objectMapper = new ObjectMapper();
     ObjectWriter objectWriter = objectMapper.writerWithDefaultPrettyPrinter();
-    Path outDir = FILE_SYSTEM.getPath("out");
-    if (!outDir.toFile().exists()) {
-      outDir.toFile().mkdir();
-    }
+//    Path outDir = FILE_SYSTEM.getPath("out");
+//    if (!outDir.toFile().exists()) {
+//      outDir.toFile().mkdir();
+//    }
     Path base = FILE_SYSTEM.getPath("/examples");
-    Path file = base.resolve("warnings.schema.json");
-    Path out = outDir.resolve("example.json");
+    Path input = base.resolve("arr5.json");
+    Path output = base.resolve("arr55.json");
     SchemaStore schemaStore = new SchemaStore();
-    Schema schema = schemaStore.loadSchema(Test.class.getResource(file.toString()).toURI());
-
+    File inputFile = new File(System.getProperty("user.dir")+input);
+    File outputFile = new File(System.getProperty("user.dir")+output);
+    Schema schema = schemaStore.loadSchema(inputFile);
+    System.out.println("******* schema : "+schema);
     Configuration config = DefaultConfig.build()
-        .setPedanticTypes(false)
+        .setPedanticTypes(true)
         .setGenerateNulls(false)
-        .setGenerateMinimal(true)
+        .setGenerateMinimal(false)
         .setGenerateAdditionalProperties(false)
-        .setUseRomanCharsOnly(false)
-        .setNonRequiredPropertyChance(0.5f)
+        .setUseRomanCharsOnly(true)
+        .setNonRequiredPropertyChance(1.0f)
         .get();
-    Object object = new Generator(config, schemaStore, new Random(1)).generate(schema, 16);
 
+    Object object = new Generator(config, schemaStore, new Random()).generate(schema, 1);
+    System.out.println("**************** generated : "+object);
     new Validator().validate(schema, object);
-    try (BufferedWriter writer = new BufferedWriter(new FileWriter(out.toFile()))) {
+    try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {
       writer.write(objectWriter.writeValueAsString(object));
     }
   }

// since OneOf and O21 are equivalent, then oneOf[ref("O21"),ref("OneOf")] must return an
// empty witness. Unfortunately, i had to encode oneOf[ref("O21"),ref("OneOf")]
// as oneOf[ref("O21"),ref("OneOf"),oneOf[mof(1),mof(1)]], i.e. oneOf[ref("O21"),ref("OneOf"),false]
// because of a bug

"root" defs [
    "root" : oneOf[ref("O21"),ref("OneOf"),oneOf[mof(1),mof(1)]],
    "OneOf" : oneOf[ref("x1"),
                  ref("x2"),
                  ref("x3"),
                  ref("x4")
                  ],
   "x1" :   notMof(2) ,
   "x2" :   notMof(3) ,
   "x3" :   notMof(5),
   "x4" :   notMof(7),
   "N01" :   not(ref("x1")),
   "N02" :   not(ref("x2")),
   "N03" :   not(ref("x3")),
   "N04" :   not(ref("x4")),
   "N11" : { ref("N01"), ref("N02") },
   "N12" : { ref("N03"), ref("N04") },
   "O11" : anyOf [ { ref("N01"), ref("x2") }, { ref("x1"), ref("N02") } ],
   "O12" : anyOf [ { ref("N03"), ref("x4") }, { ref("x3"), ref("N04") } ],
   "O21" : anyOf [ { ref("N11"), ref("O12") }, { ref("O11"), ref("N12") } ]
 ]
